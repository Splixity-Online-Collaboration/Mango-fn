{
module Lexer

open System
open FSharp.Text.Lexing
open System.Text

(* Boilerplate tracking for position handling *)
let mutable currentLine = 1
let mutable lineStartPos = [0]

let rec getLineCol pos line = function
    | p1 :: ps ->
        if pos >= p1 then (line, pos - p1)
        else getLineCol pos (line - 1) ps
    | [] -> (0, 0) // Should not happen

let getPos (lexbuf: LexBuffer<'char>) =
    getLineCol lexbuf.StartPos.pos_cnum currentLine lineStartPos

exception LexicalError of string * (int * int) // (message, (line, column))

let lexerError lexbuf s =
    raise (LexicalError (s, getPos lexbuf))

(* Recognize keywords or treat as identifier *)
let keyword (s, pos) =
    match s with
    // Elements
    | "window"        -> Parser.WINDOW pos
    | "button"        -> Parser.BUTTON pos
    | "text"          -> Parser.TEXT pos
    | "textbox"       -> Parser.TEXTBOX pos
    | "checkbox"      -> Parser.CHECKBOX pos
    | "radiobutton"   -> Parser.RADIOBUTTON pos
    | "toggleswitch"  -> Parser.TOGGLESWITCH pos
    | "calendar"      -> Parser.CALENDAR pos
    | "togglebutton"  -> Parser.TOGGLEBUTTON pos

    // Boolean & Dimensions
    | "true"          -> Parser.TRUE pos
    | "false"         -> Parser.FALSE pos
    | "isvisible"     -> Parser.IS_VISIBLE pos
    | "width"         -> Parser.WIDTH pos
    | "height"        -> Parser.HEIGHT pos

    // Text Props
    | "foreground"    -> Parser.FOREGROUND pos
    | "background"    -> Parser.BACKGROUND pos
    | "fontfamily"    -> Parser.FONTFAMILY pos
    | "fontsize"      -> Parser.FONTSIZE pos
    | "fontweight"    -> Parser.FONTWEIGHT pos
    | "fontstyle"     -> Parser.FONTSTYLE pos
    | "padding"       -> Parser.PADDING pos
    | "lineheight"    -> Parser.LINEHEIGHT pos
    | "textalign"     -> Parser.TEXTALIGN pos
    | "textwrap"      -> Parser.TEXTWRAP pos
    | "texttrim"      -> Parser.TEXTTRIM pos

    // Fontstyle Values
    | "italic"        -> Parser.ITALIC pos
    | "underline"     -> Parser.UNDERLINE pos
    | "strikethrough" -> Parser.STRIKETHROUGH pos

    // Textalign Values
    | "center"        -> Parser.CENTER pos
    | "left"          -> Parser.LEFT pos
    | "right"         -> Parser.RIGHT pos

    // Textwrap Values
    | "overflow"      -> Parser.OVERFLOW pos
    | "wrap"          -> Parser.WRAP pos
    | "forcewrap"     -> Parser.FORCEWRAP pos

    // Texttrim Values
    | "word"          -> Parser.WORD pos
    | "character"     -> Parser.CHARACTER pos
    | "notrim"        -> Parser.NOTRIM pos

    // Color Constants
    | "red"           -> Parser.RED pos
    | "blue"          -> Parser.BLUE pos
    | "green"         -> Parser.GREEN pos
    | "yellow"        -> Parser.YELLOW pos
    | "pink"          -> Parser.PINK pos

    // General Language Keywords
    | "let"           -> Parser.LET pos
    | "function"      -> Parser.FUNCTION pos

    // Fallback
    | _               -> Parser.ID (s, pos)
}

rule Token = parse
    [' ' '\t' '\r']+        { Token lexbuf } // Whitespace

  | ['\n' '\012']           {
                              currentLine <- currentLine + 1
                              lineStartPos <- lexbuf.StartPos.pos_cnum :: lineStartPos
                              Token lexbuf
                            }

  | "//" [^ '\n' '\012']*   { Token lexbuf } // Comment

  | '0' | ['1'-'9']['0'-'9']* {
                              Parser.NUM (
                                  int (Encoding.UTF8.GetString lexbuf.Lexeme),
                                  getPos lexbuf
                              )
                            }

  | ['a'-'z' 'A'-'Z']['a'-'z' 'A'-'Z' '0'-'9' '_']* {
                              keyword (
                                  Encoding.UTF8.GetString lexbuf.Lexeme,
                                  getPos lexbuf
                              )
                            }

  | '"' (
        [' ' '!' '#'-'&' '('-'[' ']'-'~'] |
        '\\' ['n' 't' '\'' '"' '\\']
      )* '"' {
                              let str0 = Encoding.UTF8.GetString lexbuf.Lexeme
                              let str1 = str0.Substring(1, str0.Length - 2)
                              Parser.STRINGLIT (AbSyn.fromCString str1, getPos lexbuf)
                            }
  | '#' ['0'-'9' 'a'-'f' 'A'-'F'] ['0'-'9' 'a'-'f' 'A'-'F'] ['0'-'9' 'a'-'f' 'A'-'F'] ['0'-'9' 'a'-'f' 'A'-'F'] ['0'-'9' 'a'-'f' 'A'-'F'] ['0'-'9' 'a'-'f' 'A'-'F'] {
                              let str = Encoding.UTF8.GetString lexbuf.Lexeme
                              Parser.HEXCOLOR (str, getPos lexbuf)
                            }
  | '#' ['0'-'9' 'a'-'f' 'A'-'F'] ['0'-'9' 'a'-'f' 'A'-'F'] ['0'-'9' 'a'-'f' 'A'-'F'] ['0'-'9' 'a'-'f' 'A'-'F'] ['0'-'9' 'a'-'f' 'A'-'F'] ['0'-'9' 'a'-'f' 'A'-'F'] ['0'-'9' 'a'-'f' 'A'-'F'] ['0'-'9' 'a'-'f' 'A'-'F'] {
                              let str = Encoding.UTF8.GetString lexbuf.Lexeme
                              Parser.HEXCOLOR (str, getPos lexbuf)
                            }
  | ','                     { Parser.COMMA (getPos lexbuf) }
  | '{'                     { Parser.LEFT_CURLY_BRACKET (getPos lexbuf) }
  | '}'                     { Parser.RIGHT_CURLY_BRACKET (getPos lexbuf) }
  | '('                     { Parser.LEFT_PAR (getPos lexbuf) }
  | ')'                     { Parser.RIGHT_PAR (getPos lexbuf) }
  | ':'                     { Parser.COLON (getPos lexbuf) }
  | '='                     { Parser.EQUAL (getPos lexbuf) }
  | eof                     { Parser.EOF (getPos lexbuf) }

  | _                       { lexerError lexbuf "Illegal symbol in input" }
