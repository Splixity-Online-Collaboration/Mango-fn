%{

let p0 = (0,0)

open FSharp.Text.Parsing
open AbSyn

(* parse-error function *)
let mutable ErrorContextDescriptor : string = ""

let parse_error_rich =
  Some (fun (ctxt: ParseErrorContext<_>) ->
    ErrorContextDescriptor <-
      match ctxt.CurrentToken with
      | None -> "At beginning of input\n"
      | Some token -> sprintf "at token %A\n" token
  )

let add_ui_elements window elements = 
  match window with
  | Window (name, width, height, icon, _, pos) -> Window (name, width, height, icon, elements, pos)

let default_button_props pos = [IsVisible (true, pos) ]
let default_text_props pos = [ForeGround (Hex (HexCode(byte 255,byte 255,byte 255,byte 255), pos), pos) ]


let parse_hex_code (s: string) : (byte * byte * byte * byte) option =
    let hex = if s.StartsWith("#") then s.Substring(1) else s
    let tryByte i = System.Byte.TryParse(hex.Substring(i,2), System.Globalization.NumberStyles.HexNumber, null)
    match hex.Length with
    | 6 ->
        let (rOk, r), (gOk, g), (bOk, b) =
            tryByte 0, tryByte 2, tryByte 4
        if rOk && gOk && bOk then Some (r, g, b, 255uy) else None
    | 8 ->
        let (rOk, r), (gOk, g), (bOk, b), (aOk, a) =
            tryByte 0, tryByte 2, tryByte 4, tryByte 6
        if rOk && gOk && bOk && aOk then Some (r, g, b, a) else None
    | _ -> None

%}

//information-carrying tokens
%token <int * Position> NUM
%token <string * Position> ID STRINGLIT HEXCOLOR
//keywords
%token <Position> WINDOW 
%token <Position> BUTTON TEXT TEXTBOX CHECKBOX RADIOBUTTON CALENDAR TOGGLEBUTTON TOGGLESWITCH
%token <Position> IS_VISIBLE TRUE FALSE WIDTH HEIGHT FUNCTION LET
%token <Position> FOREGROUND BACKGROUND FONTFAMILY FONTSIZE FONTWEIGHT FONTSTYLE PADDING LINEHEIGHT TEXTALIGN TEXTWRAP TEXTTRIM
%token <Position> ITALIC UNDERLINE STRIKETHROUGH
%token <Position> RED BLUE GREEN YELLOW PINK
%token <Position> CENTER LEFT RIGHT
%token <Position> OVERFLOW WRAP FORCEWRAP
%token <Position> WORD CHARACTER NOTRIM
%token <Position> EOF COMMA LEFT_CURLY_BRACKET RIGHT_CURLY_BRACKET COLON LEFT_PAR RIGHT_PAR EQUAL

%start Prog
%type <AbSyn.Window> Prog
%type <AbSyn.Window> Window

%type <AbSyn.UIElement list> UIElements
%type <AbSyn.UIElement> UIElement
%type <AbSyn.ButtonProp list> ButtonProps
%type <AbSyn.ButtonProp> ButtonProp
%type <AbSyn.TextBlockProp> TextProp
%type <AbSyn.TextBlockProp list> TextProps
%type <AbSyn.ColorT> Color


%type <AbSyn.FunctionT> Function
%type <AbSyn.Stmt list> Statements
%type <AbSyn.Stmt> Stmt
%type <AbSyn.Exp> Exp

%%

Prog :    Window EOF   { $1 }
;

Window :  WINDOW STRINGLIT { Window (fst $2, None, None, None, [], $1) }
    | WINDOW STRINGLIT NUM NUM { Window (fst $2, Some (fst $3), Some (fst $4), None, [], $1) }
    | WINDOW STRINGLIT NUM NUM STRINGLIT { Window (fst $2, Some (fst $3), Some (fst $4), Some (fst $5), [], $1) }
    | Window LEFT_CURLY_BRACKET UIElements RIGHT_CURLY_BRACKET { add_ui_elements $1 $3 }
;

UIElements : UIElement UIElements       { $1 :: $2 }
           | UIElement                  { $1 :: [] }
;

ButtonProps : ButtonProp ButtonProps    { $1 :: $2 }
            | ButtonProp                { $1 :: [] }
;

TextProps : TextProp TextProps          { $1 :: $2 }
          | TextProp                    { $1 :: [] }

UIElement : BUTTON STRINGLIT { Button (fst $2, default_button_props $1, $1) }
          | BUTTON STRINGLIT LEFT_CURLY_BRACKET ButtonProps RIGHT_CURLY_BRACKET { Button (fst $2, $4, $1) }
          | TEXT STRINGLIT { TextBlock (fst $2, default_text_props $1 ,$1) }
          | TEXT STRINGLIT LEFT_CURLY_BRACKET TextProps RIGHT_CURLY_BRACKET { TextBlock (fst $2, $4, $1) }
          | TEXTBOX STRINGLIT { TextBox (fst $2, $1) }
          | CHECKBOX STRINGLIT { CheckBox (fst $2, $1) }
          | RADIOBUTTON STRINGLIT { RadioButton (fst $2, $1) }
          | TOGGLESWITCH STRINGLIT { ToggleSwitch (fst $2, $1) }
          | CALENDAR { Calendar $1 }
          | TOGGLEBUTTON { ToggleButton $1 }
;

ButtonProp : IS_VISIBLE COLON TRUE { IsVisible (true, $1) }
  | IS_VISIBLE COLON FALSE { IsVisible (false, $1) }
  | WIDTH COLON NUM { Width (fst $3, $1) }
  | HEIGHT COLON NUM { Height (fst $3, $1) }
;

Color :
  | HEXCOLOR {
      match parse_hex_code (fst $1) with
      | Some rgba -> Hex (rgba, snd $1)
      | None -> failwithf "Invalid hex color: %s" (fst $1)
    }
  | RED    { ColorName (Red, $1) }
  | BLUE   { ColorName (Blue, $1) }
  | GREEN  { ColorName (Green, $1) }
  | YELLOW { ColorName (Yellow, $1) }
  | PINK   { ColorName (Pink, $1) }
;

FontStyle:
    ITALIC         { Italic }
  | UNDERLINE      { Underline }
  | STRIKETHROUGH  { StrikeThrough }
;

FontStyles : FontStyle FontStyles       { $1 :: $2 }
           | FontStyle                  { $1 :: [] }
;

TextAlign :
    CENTER { Center }
  | LEFT { Left }
  | RIGHT { Right }
;

TextWrap :
    OVERFLOW { Overflow }
  | WRAP { Wrap }
  | FORCEWRAP { ForceWrap }
;

TextTrim :
    WORD { Word }
  | CHARACTER { Character }
  | NOTRIM { NoTrim }
;

Padding :
    NUM COMMA NUM COMMA NUM COMMA NUM {
      Uniform (fst $1, fst $3, fst $5, fst $7)
    }
  | NUM COMMA NUM {
      Symmetric (fst $1, fst $3)
    }
;

TextProp : FOREGROUND COLON Color { ForeGround ($3, $1) }
         | BACKGROUND COLON Color { BackGround ($3, $1) }
         | FONTFAMILY COLON STRINGLIT { FontFamily (fst $3, $1)}
         | FONTSIZE COLON NUM { FontSize (fst $3, $1) }
         | FONTWEIGHT COLON NUM { FontWeight (fst $3, $1)}
         | FONTSTYLE COLON FontStyles { FontStyle (List.rev $3, $1)}
         | PADDING COLON Padding { Padding ($3, $1) }
         | LINEHEIGHT COLON NUM { LineHeight (fst $3, $1)}
         | TEXTALIGN COLON TextAlign { TextAlign($3, $1) }
         | TEXTWRAP COLON TextWrap { TextWrap($3, $1) }
         | TEXTTRIM COLON TextTrim { TextTrim($3, $1) }
;

Function : FUNCTION ID LEFT_PAR RIGHT_PAR LEFT_CURLY_BRACKET Statements RIGHT_CURLY_BRACKET { Function (fst $2, $6, $1) }
;

Statements : Stmt Statements { $1 :: $2 }
           | Stmt { $1 :: [] }
;

Stmt : LET ID EQUAL Exp { Let (fst $2, $4, $1) }
;

Exp : NUM     { Constant (Int (fst $1), snd $1) }
  | STRINGLIT { Constant (String (fst $1), snd $1) }
  | ID        { Var $1 }
  | TRUE      { Constant (Bool true, $1) }
  | FALSE     { Constant (Bool false, $1) }
;